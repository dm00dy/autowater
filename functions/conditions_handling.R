# Basic error handling expr
#
# Based on Hadley Wickham's Advanced R book
#
# nelliott, June 2015

# Requires base condition objects
#source

################
## Conditions ##
################

# Constructor function for a condition of (sub)class value_changed.  Signalled when a passed value is changed to a
# default one because of some problem with the passed value.
#
# Args:
#   text: Explanatory text to append to the condition message.
#   condClass (optional): the overall class (type) of condition this is.  Must be "error", "warning", or "message".
#     Defaults to "error".
#   trigger (optional): The condition that caused this condition to be signalled.  Appended to returned condition.
#     Defaults to NA.
#   ... (optional): Additional arguments to append to the constructed condition, providing more detail.
#
# Returns:
#   A condition object of classes name_of_function and condClass.
value_changed <- function(text, condClass = "warning", trigger = NA, ...) {
  
  msg <- "Invalid value replaced"
  cond <- condition(condClass = condClass, msgBase = msgBase, msgDetail = text, trigger = trigger, ...)
  return(cond)
  
}

###############
## Functions ##
###############

# Function to substitue a value if an error is generated by a block of code.  Can substitute value
# silently or warn.  A wrapper for try.
#
# Args:
tryReturn <- function(expr, errorValue = NA, silent = FALSE) {
  
  # Evaluate
  tryValue <- try(expr, silent = silent)
  
  # If error
  if (is.tryerror(tryValue)) {
    
    # Substitute silently
    if (identical(silent, TRUE)) {
      message(message_trace("Substituting value silently.", "tryReturn"))
      tryValue <- errorValue
      
    # Warn and substitute
    } else {
      message(message_trace("Substituting value with warning.", "tryReturn"))
      tryCatch(expr,
               condition = function(c) {
                 tryValue <<- errorValue
                 warning(warning_value_changed("Changing invalid result in passed code.", c, fxnName = getFxnName(), 
                                                    originalValue = quote(expr), substitutedValue = errorValue))  
               },
               warning = function(w) {}
               )
    }
  
  }
 
  return(tryValue)
  
}

tryCatchCalls <- function(expr, sysCalls = c(), ...) {
  
  
  
  tryCatch({
    sysCalls <- c()
    withCallingHandlers(expr, error = function(e) {sysCalls <<- sys.calls()})
    }, ...)
  
}

#tryCatch({
#  sysCalls <- c()
#  withCallingHandlers(stop("test error"), error = function(e) {sysCalls <<- sys.calls()})
#}, error = function(e2) print(sysCalls))

# A function that will log conditions generated during the evaluation of a block of R code.  Note that any errors
# raised will be logged but not trapped; enclose in tryCatch block for responding to errors.
#
# Args:
#   expr: The block of R code to be evaluated.
#   logFunctionName (optional): The name of the log function to call when a condition is generated; defaults to
#     logCondition.  Function must accept a condition as its first argument and also accept the additional parameters
#     toDest (boolean), toFile (boolean), and debugLogger (boolean).
#   logOutLevel (optional): The minimum level of condition to output (usually to stdout()); defaults to "TRACE".
#     Must be one of the condition severities defined in conditionSeverityLevels().
#   logFileLevel (optional): The minimum level of condition to write to a log file; defaults to "WARN".
#     Must be one of the condition severities defined in conditionSeverityLevels().
#   debugLogger (optional): Whether or not to run the logging function in debug mode; defaults to FALSE.
#   ... (optional): Additional arguments to pass to the logging function, e.g., logFile.
#
# Returns:
#   Nothing
withConditionLogging <- function(expr, logFunctionName = "logCondition", 
                                 logOutLevel = "TRACE", logFileLevel = "WARN", 
                                    debugLogger = FALSE, ...) {
  
  # Check output level
  if (!(logOutLevel %in% conditionSeverityLevels())) {
    logOutLevel <- "TRACE"
    warning(warning_value_changed("Improper logging level passed as logOutLevel to withConditionLogging;
                                  changing to default of TRACE."))
  }
  logOutLevel <- factor(logOutLevel, levels = conditionSeverityLevels(), ordered = TRUE)
  
  # Check log file level
  if (!(logFileLevel %in% conditionSeverityLevels())) {
    logFileLevel <- "WARN"
    warning(warning_value_changed("Improper logging level passed as logFileLevel to withConditionLogging;
                                  changing to default of WARN."))
  }
  logFileLevel <- factor(logFileLevel, levels = conditionSeverityLevels(), ordered = TRUE)
  
  # Run the code expr with the logging handlers
  withCallingHandlers(expr,
                      
                      condition = function(cond) {
                        
                        # Check condition severity
                        sev <- conditionSeverity(cond)
                        if (sev >= logOutLevel) {
                          toDest <- TRUE
                        } else {
                          toDest <- FALSE
                        }
                        if (sev >= logFileLevel) {
                          toFile <- TRUE
                        } else {
                          toFile <- FALSE
                        }
                        
                        # Log
                        cond$callLog <- sys.calls()
                        lg <- try(match.fun(logFunctionName)(cond, toDest = toDest, toFile = toFile,
                                                       debugLogger = debugLogger, ...), silent = !debugLogger)
                        if(is.tryerror(lg)) stop("Failure outputting log (in withConditionLogging).")
                        
                        # Call custom error handling
                        #if (is.error(cond)) call custom handler? invoke restart?
                        
                        # Muffle messages and warnings
                        if (is.message(cond)) invokeRestart("muffleMessage")
                        if (is.warning(cond)) invokeRestart("muffleWarning")
                      
                      }
                      
  )

}